#    脑图

## 实例化

```markdown
1. 脑图的实例化过程和我们的图谱实例化过程是一致的 只不过调用的 实例化的类 由原来的  G6.Graph 变成了 G6.TreeGraph
2. 另外数据结构 也变成了 树层级的结构
3. layout  布局  由 
compactBox 紧凑树布局 从根节点开始，同一深度的节点在同一层，并且布局时会将节点大小考虑进去。
dendrogram 生态树布局。不管数据的深度多少，总是叶节点对齐。不考虑节点大小，布局时将节点视为 1 个像素点。
indented 缩进树布局。每个元素会占一行/一列。
脑图布局。深度相同的节点将会被放置在同一层，与 compactBox 不同的是，布局不会考虑节点的大小。
```

## 初始化

```markdown
1. 这里我们用 脑图布局 实例化一颗树
```

```js
const treeGraph = new G6.TreeGraph({
    container: 'container',
    width: window.innerWidth - 40,
    height: window.innerHeight - 40,
    defaultNode: {
        type: 'rect',
        style: {
            width: 100,
            height: 30,
            radius: 4,
            fill: '#ecf6fc',
            stroke: '#1890ff',
        },
        labelCfg: {
            style: {
                fontSize: 14,
            },
        },
    },
    // 这里我们使用自定义边
    defaultEdge: {
        type: 'my-edge',
    },
    layout: {
        type: 'mindmap',
        getHGap: () => 50, // 节点和节点的 纵向间距
        getVGap: () => 20, // 节点和节点的 横向间距
    },
    modes: {
        default: [
            'drag-canvas',
            'zoom-canvas',
            'drag-node',
            // 展开的行为
            {
                type: 'collapse-expand',
                onChange(item, collapsed) {
                    const data = item.get('model');

                    data.collapsed = collapsed;
                    return true;
                },
            },
        ],
    },
    fitView: true,
})

treeGraph.data(data)
treeGraph.render()
```

## 自定边

```markdown
1. 这我们使用了 自定义边的形式 把脑图的 连线绘制成 转交是弧线的形式
```

```js
这里我们的边 可以理解为路径 
它的数据模型 是一个二位数据 
分别为 
M 是一个数组 里面 第0 个元素 是点的横坐标 第1个元素 是 点的纵坐标
L 也是一个数组  第0 个元素 是端点的横坐标 第1个元素 是 端点的纵坐标
这样 通过 M L  有了 坐标之后 就可以连成一条之前
```

```js
G6.registerEdge('my-edge', {
    draw(cfg, group) {
        // 1. 绘制自定义边 首先我们要拿到 每个节点连线处的 起始点坐标 和 终点坐标
        const {startPoint,endPoint} = cfg
        // 2. 这里因为有的节点 会在起始点的上面 或者 下面 所以我们要判断一下 才能 绘制出更准确的线段
        const diffY =endPoint.y - startPoint.y 
        const offsetX = 10 // 如果 起始元素 和 终点元素 不在一条直线上 我们多出来一点线段 让线条更加好看
        // 3. 如果 终点的 纵坐标 和 起点的总左边 一样 说明在一条水平线上 我们就绘制一条水平的路径即可
        const path = diffY === 0? 
        [
            // M 就是 起始点的横纵坐标
            ['M',cfg.startPoint.x,cfg.startPoint.y],
            // L 就是 绘制一条直线  链接到终点的横纵坐标
            ['L',cfg.endPoint.x,cfg.endPoint.y]
        ]
        :
        // 4. 这里 因为 由的终点在 起始点的上面 由的在下面 我们需要做更加复杂的线段绘制
        [
            ['M',cfg.startPoint.x,cfg.startPoint.y],
            ['L',cfg.startPoint.x+ offsetX,cfg.startPoint.y],
            ['L',cfg.startPoint.x+ offsetX,cfg.endPoint.y + (diffY>0? -10:10)],
            ['Q',cfg.startPoint.x+ offsetX ,cfg.endPoint.y , cfg.startPoint.x+ offsetX+10,cfg.endPoint.y],
            ['L',cfg.endPoint.x,cfg.endPoint.y]
        ]


        const shape = group.addShape('path', {
            attrs: {
                path,
                stroke: '#1890ff',
                ...cfg,
            },
            name: 'right-tree-edge',
        });
        return shape
    }
})
```

```js
[
    ['M',cfg.startPoint.x,cfg.startPoint.y],
    ['L',cfg.startPoint.x+ offsetX,cfg.startPoint.y],
    // 准备要拐角的起始点 因为由可能在终点有可能在起始点上面或者下面 所以这里做了一些坐标的判断
    ['L',cfg.startPoint.x+ offsetX,cfg.endPoint.y + (diffY>0? -10:10)],
    // 拐角的直角点 带 拐角结束的 点 的坐标
    ['Q',cfg.startPoint.x+ offsetX ,cfg.endPoint.y , cfg.startPoint.x+ offsetX+10,cfg.endPoint.y],
    // 终点的坐标
    ['L',cfg.endPoint.x,cfg.endPoint.y]
]
// 如下图所绘
```

![](C:\Users\Administrator\Desktop\整理的笔记\G6\Snipaste_2022-03-17_16-36-11.png)

# 实例

![](C:\Users\Administrator\Desktop\整理的笔记\G6\Snipaste_2022-03-28_18-39-38.png)

```markdown
1. 我们现在 来画上面的脑图
2. 第一个每条线上 都会有文字 这个是根据 每个子数据上的 note值 去画的 
3. 这里有文本节点 和 文字节点 当当前节点 的 nodeType 为 node 的时候 就是一个 圆角矩形的节点 如果 没有 我们就是把这个节点的背景和边框 全都设置为透明
4. 每条线上都会 有 减号 来控制收缩 
5. 右键的时候 会有编辑节点 和 删除节点的菜单 
```

## 初始化

```js
const graph = new G6.TreeGraph({
    container: 'container', // 初始化在哪个容器上 
    height: window.innerHeight - 40,  // 画布的高
    width: window.innerWidth, // 画布的款
    layout: {
        type: 'mindmap',  // 画布的布局 是脑图
        getHGap: () => 50, // 节点 和节点 之间的 纵向距离
        getVGap: () => 20, // 节点 和 节点之间的 横向距离
    },
    defaultNode: {
        type: 'my-node', // 使用 自定义节点
        style: {
            width: 100,  // 节点的宽
            height: 30, // 节点的高
            radius: 4, // 节点的圆角
            fill: '#ecf6fc', // 填充颜色
            stroke: '#999', // 边框颜色
        },
        labelCfg: {
            // 字体的的大小
            style: {
                fontSize: 14,
            },
        },
    },
    // 节点的自定义便
    defaultEdge: {
        type: 'my-edge'
    },
    plugins: [menu], // 使用了右键菜单插件
    modes: {
        default: [
            'drag-canvas', // 可以拖拽画布
            'zoom-canvas', // 可以缩放画布
            'drag-node', // 可以拖拽节点
        ],
    },
    fitView: true,  // 是否居中
    minZoom: 0.7,  // 最小缩放比例
    maxZoom: 1, // 最大缩放比例
})
graph.data(data) // 渲染数据
graph.render() // 渲染数据
```

## 绘画自定义节点

```js
1. 节点有 圆角矩形的节点  还有 文字节点
2. 是根据 nodeType 字段区分的 如果当前节点的数据 里 有nodeTyoe 为 node 那么就绘制 圆角矩形节点
3. 如果没有 就绘制一个透明的圆角矩形 然后绘制文字节点
4. 最后要结成 rect 节点类 否则坐标连线会乱
5. 最后还要绘制 展开 和节点的按钮
```

```js
/* 注册自定义节点 */

  G6.registerNode('tree-node', {
    draw (cfg, group) {
      // 看看当前节点的数据 是不是 节点的类型
      const isNodeStyle = cfg.nodeType === 'node';  
      // 拿到默认节点的央视
      const style = this.getShapeStyle(cfg, group); 
      // 把默认样式重新覆盖一下
      const textStyle = { ...style }; 
      // 算出文字节点的宽
      const size = G6.Util.getTextSize(cfg.label, 14);
      // 如果你当前节点 不是 node 类型
      if (!isNodeStyle) {
        // 删除 填充颜色 删除 边框 因为是文字
        delete textStyle.fill;
        delete textStyle.stroke;
        // 把宽重新配置  
        textStyle.width = size[0] + 12;
      }
      // 如果你是 node节点类型 就设置style 样式 如果不是 就设置 textstyle 样式 两个样式的宽度不一样  
      const attrs = isNodeStyle ? style : textStyle;
      // 开始绘制圆形节点  
      const shape = group.addShape('rect', {
        attrs,
        name: 'rect-node', // 当点击节点的时候 我们可以通过cfg.name 去区分 你点击的节点是什么
      });
	  // 开始设置 文本节点
      group.addShape('text', {
        attrs: {
          fontSize: 14, // 字体大小
          fill:     '#666', // 填充颜色
          text:     cfg.label, // 文字是什么
          x:        -style.width / 2 + 6, // 设置 文字的坐标
          y:        style.height / 2 - 8, // 设置文字的坐标
        },
        name: 'node-label',
      });
	  // 如果你当前节点的数据 还有 children 那我们就要绘制 展开 和 收缩的按钮
      if (cfg.children) {
         // 因为 node节点的类型的节点 和 你 文字节点 中间的连线不一样 所以这里我们主要 算我们绘制的展开的按钮的 横坐标
        const circleX = !isNodeStyle && style.width > size[0] ? (-style.width / 2 + size[0] + 22) : (attrs.width / 2 + 11);
		// 绘制一个原型
        group.addShape('circle', {
          attrs: {
            r:      7,
            fill:   '#fff',
            stroke: '#ccc',
            x:      circleX,
          },
          name: 'node-icon',
        });
		// 原型里面还有 - 号文字 来表示 当前节点的下级 是展开的 可以收缩 如果是 + 号 就表示当前节点的下级是收缩的可以展开
        const iconX = !isNodeStyle && style.width > size[0] ? (-style.width / 2 + size[0] + 17) : (style.width / 2 + 6);
	    // 开始绘制文本节点 也就是 - 号 然后调整对应的位置 放在我们圆圈里
        group.addShape('text', {
          attrs: {
            text:     '-',
            fontSize: 16,
            fill:     '#ccc',
            cursor:   'pointer',
            x:        iconX,
            y:        6,
          },
          name: 'node-icon-text',
        });
      }
      // 最后返回这个节点
      return shape;
    },
    update (cfg, node) {
     ...好多更新的逻辑的代码
    },
  }, 'rect');
```

## 绘制自定义边

```js
1. 如果节点的纵坐标是一样的 那么我们直接就可以连线
2. 如果不 如果不一样 我们就需要 多画出来一根线 让图看着更舒服
3. 节点的 target(目标节点) 如果 有 note 字段 我们需要 把他显示在线上
```

```js
G6.registerEdge('right-tree', {
    draw (cfg, group) {
      // 设置一个 x坐标的偏移量
      const xOffset = 22;
      // 设置一个纵坐标的偏移量  
      const yOffset = 10;
      // 拿到 起始点的 x y 坐标  和 重点的 x y 坐标  
      const { startPoint, endPoint } = cfg;
      const Ydiff = endPoint.y - startPoint.y;
      // 这个就是判断 终点是在 起始点的上方 还是下方 
      const left = startPoint.x - endPoint.x > 0;
      // 设置拐点的坐标 可以参照我们上面的自定义边  
      const QPoint = {
        x: left ? startPoint.x - xOffset : startPoint.x + xOffset,
        y: endPoint.y,
      };
      // 如果 起始点 和 终点的坐标一样 那么我们直接就画一条路径即可 如果不一样我们就要分上面的圆弧路径还是下面的圆环路径  
      const path = Ydiff === 0 ? [
        ['M', startPoint.x + xOffset, startPoint.y],
        ['L', endPoint.x, endPoint.y],
      ] : [
          ['M', startPoint.x, startPoint.y],
          ['L', QPoint.x, startPoint.y],
          ['L', QPoint.x, endPoint.y + (Ydiff > 0 ? -yOffset : yOffset)],
          ['Q', QPoint.x, QPoint.y, left ? QPoint.x - yOffset : QPoint.x + yOffset, endPoint.y],
          ['L', endPoint.x, endPoint.y],
      ];
	  // 开始绘画路径
      const shape = group.addShape('path', {
        attrs: {
          path,
          stroke: '#666',
          ...cfg,
        },
        name: 'right-tree-edge',
      });
	 // 然后拿到 终点的 数据模型 也就是 targetNode
      const { note } = cfg.targetNode.getModel();
	 // 如果有note 字段 我们就要在线上绘制文字
      if (note) {
        // 这坐标我们设置在拐点 稍微 向右侧一点  
        const label = group.addShape('text', {
          attrs: {
            x:        QPoint.x + 6,
            y:        endPoint.y - 3,
            text:     note || '',
            fill:     '#999',
            fontSize: 12,
          },
          name:   'right-tree-note',
          zIndex: 10,
        });
		
        group.sort(); // 这个不清楚
        label.toFront(); // 让文字 在最前面显示
      }
      return shape;
    },
```

## 节点的收缩和展开

```markdown
1. 首先我们要给 所有的节点 添加点击事件
2. 这里我们可以在回调函数里  拿到 当前的节点 然后可以根据 name 去区分 你点击的到底是不是我们的圆圈节点 圆圈节点的name 为 
3. 然后获取到我们这个 node-icon-text 和 node-icon
4. 然后把我的数据模型的 collapsed  取反
5. 然后调用我们 图谱实例的 updateItem 函数  传入我们的节点 和我们修改后的数据模型
6. 这里我们需要在我们 自定义节点的 update函数里 修改我们的原型节点的 文字 如果是 collapsed 是true 那么应该显示 - 号 如果是 false 那么应该显示 + 号
7. 然后更新视图
```

```js
this.graph.on('node:click', e => {
    // 拿到 点击节点的数据模型 
    const model = e.item.getModel();
    // 看看 当前点击的节点 是不是 点击的我们的 小圆圈的节点
    if(e.target.cfg.name === 'node-icon-text') {
      // 更开数据模型
      model.collapsed = !model.collapsed;
      // 更新状态 + - 号的状态
      this.graph.updateItem(e.item, model);
      // 更新视图  
      this.graph.layout();
    } else {
     ... 路径导航的电脑
    }
    e.item.toFront();
  });

// 自定义节点的逻辑

/* 注册自定义节点 */

export default G6 => {
  G6.registerNode('tree-node', {
    draw (cfg, group) {
      ... 绘制 自定义好多代码    
      return shape;
    },
    update (cfg, node) {
      // 刚刚我们调用graph 的 updateItem 就会走到这里 第一个参数 是节点的配置数据 第二个参数是节点的实例
      // 通过   node.getContainer 拿到 父级的图谱 也就是 容器
      const group = node.getContainer();
      // 在通过容器 拿到 你所有绘制的自定义节点   
      const children = group.get('children');
      // 如果 你出发的时候 找到 你的小圆圈 节点  
      const icon = children.find(child => child.cfg.name === 'node-icon-text');
      // 根据 你数据模型的   collapsed 来设置  + - 号
      if (icon) {
        icon.attr({
          text: cfg.collapsed ? '+' : '-',
        });
      }
    },
  }, 'rect');
};

```

## 节点的编辑

```js
1. 首先节点的编辑在 右键菜单 中 这个右键菜单 我们是通过G6的插件 去配置的
2. 当我们点击 右键 选择编辑节点的时候 首先我们要拿到 节点的id 和 这个节点的 坐标
3. 我们会把 input 框 设置为显示 坐标设置为我们的 节点坐标 这里需要拿到的是 画布的鼠标坐标
4. 然后 更改值 后 我们会通过id 找到这个节点 然后 拿到 这个节点的数据模型 更改为input 的值
5. 最后 调用 update 函数 更新数据模型 刷新视图
```

```js
// 配置 右键插件
const menu = new G6.Menu({
    offsetY:   -20,
    itemTypes: ['node'], // 这里 只有当前几右键的节点时候才会出现框
    getContent(e) {
      return `
        <p class="menu-item" command="edit-node">编辑文本</p>
        <p class="menu-item" command="delete-node">删除节点</p>
      `;
    },
    handleMenuClick(target, item) {
      const command = target.getAttribute('command');
	  // 这里就可以区分是 编辑节点 还是 删除节点了
      switch (command) {
        case 'edit-node':
          vm.editNode(item);
          break;
        case 'delete-node':
          vm.deleteNode(item);
          break;
      }
    },
  });
```

```js
// 编辑节点
    editNode(item) {
      // 拿到节点的数据模型
      const model = item.getModel();
      // 这拿到 相对于窗口的坐标   
      const { cacheCanvasBBox } = item.get('group').cfg;
	  //  让input 框显示
      this.showInput = true;
      this.inputValue = model.label; // 让input框的 等于我们的节点 label
      this.currentNode.id = model.id; // 拿到当前节点的ID
      this.input.x = cacheCanvasBBox.x + 40; // 设置 input的框的坐标 把节点挡住
      this.input.y = cacheCanvasBBox.y + 40;
      this.$nextTick(() => {
        this.$refs.inputController.focus(); // 自动获取焦点
      });
    },
        
// input 框失去 焦点的时候 修改节点的值
        
 inputBlur() {
  // 显示input框隐藏   
  this.showInput = false;
  // 通过 点击节点的id 找到 这个节点	
  const item = this.graph.findById(this.currentNode.id);
  // 通过节点 找到 数据模型   
  const model = item.getModel();
  // 更新数据模型
  model.label = this.inputValue;
  // 调用update 函数 重新渲染数据模型   
  this.graph.updateItem(item, model);
},
    
    
 G6.registerNode('tree-node', {
    draw (cfg, group) {
      ... 好多代码
      return shape;
    },
    update (cfg, node) {
      // 拿到容器  
      const group = node.getContainer();
      // 找到孩子  
      const children = group.get('children');
      // 找到我们点击的更新的节点 name  
      const nodeLabel = children.find(child => child.cfg.name === 'node-label');
	  // 然后更新数据模型
      if (nodeLabel) {
        nodeLabel.attr({
          text: cfg.label,
        });
      }
  }, 'rect');    
```

## 节点的删除

```js
1. 首先我们要知道 删除节点的id 在插件里 回调参数可以拿到 item 调用 item.get('id') 可以拿到
2. 这里为了 在删除的时候 可以让父节点在最上面显示 我们还要 拿到父节点的id 通过 父节点的id找到 父节点的实例调用 toFront 删除的时候 显示在最前面
3. 如果子节点都删除 我们还要删除加减号 所以每次删除的时候 我们都要拿到父节点的数据模型 判断 还有没有children 如果没有了 我们就要通过父节点 拿到 图谱 然后 找到这个图谱下你绘制的 所有节点图形 通过name 找到 我们的圆圈 和 减号 并且删除
```

```js
const menu = new G6.Menu({
        offsetY: -20,
        itemTypes: ['node'],
        getContent(e) {
            return `
        <p class="menu-item" command="edit-node">编辑文本</p>
        <p class="menu-item" command="delete-node">删除节点</p>
      `;
        },
        handleMenuClick(target, item) {
            const command = target.getAttribute('command');

            switch (command) {
                case 'edit-node':
                    editNode(item);
                    break;
                // 插件会走到这里 参数就是 节点的实例    
                case 'delete-node':
                    deleteNode(item);
                    break;
            }
        },
    });

function deleteNode(item) {
	    // 通过节点实例 拿到 节点id
        const id = item.get('id')
        // 这里判断一下 必须是子节点
        if (id.length > 1) {
            // 因为节点 1-1-1  是 1-1 的子节点 所以我们通过规律 删除 拿到父节点id
            const parentId = id.substring(0, id.length - 2);
            // 通过父节点id 找到 父节点实例
            const parent = graph.findById(parentId);
		   // 放在最上面	
            parent.toFront()
        }
    	// 然后删除自己
        graph.removeChild(id)
    	// 这多写了一写 逻辑和上面是一样的 
        if (id.length > 1) {
            const parentId = id.substring(0, id.length - 2);
            const parent = graph.findById(parentId);
            // 拿到父节点 的数据模型
            const model = parent.get('model');
		   // 每次删除完了 看下 数据模型下还有没有 子节点的数据 如果没有了 我们就开始删除加减号	
            if (model.children.length === 0) {
                // 拿到 父节点的图谱
                const group = parent.get('group');
                // 这里我们一共绘制了 四个节点  圆角矩形 文字 小圆圈 加减号
                const { children } = group.cfg;
                // 这里我们循环 找到 加减号 通过name
                const icon = children.find(child => child.cfg.name === 'node-icon');
                const iconText = children.find(child => child.cfg.name === 'node-icon-text');
                // 然后 删除加减号
                if (icon) {
                    icon.remove();
                    iconText.remove();
                }
            }
        }
    }
```

## 导航功能

- 点击节点的时候  视图会切换到当前节点 所显示的内容

- 视图上会有导航 可以点击点击返回

- 以上我们都是调用 changeData 去更新数据 页面也会变化

```js
// 这里我们已经区分了 点击节点的的时候 是 加减号 还是节点等 所以

 this.graph.on('node:click', e => {
        // if 里面就是我们点击加减号的逻辑
        const model = e.item.getModel();
        if(e.target.cfg.name === 'node-icon-text') {
          /* 展开按钮的事件 */
          model.collapsed = !model.collapsed;
          this.graph.updateItem(e.item, model);
          this.graph.layout();
        } else {
          // 1. 拿到我们当前点击的id
          this.currentNode.id = model.id;
          // 这个是导航栏的数组  
          this.crumbNavs = [];
          // 查找所有的节点路径
          this.getParentNodes(data, model.id);
          // 最后调取这个方法 去更新页面视图  
          this.graph.changeData(JSON.parse(JSON.stringify(model)));
        }
        e.item.toFront();
      });
    },
```

# 节点拖拽和画布移动

- 左侧是无聊栏 里面有 矩形 椭圆 和菱形等 
- 右侧就是我们的画布区域

- 代码结构

```vue
<template>
  <div
    id="itemPanel"
    ref="itemPanel"
  >
    <i class="iconfont icon-h-drag" />
    <div class="icon-tool">
      <i
        draggable="true"
        data-shape="circle"
        class="iconfont icon-circle"
      />
      <i
        draggable="true"
        data-shape="rect"
        class="iconfont icon-rect"
      />
      <i
        draggable="true"
        data-shape="ellipse"
        class="iconfont icon-ellipse"
      />
      <i
        draggable="true"
        data-shape="diamond"
        class="iconfont icon-diamond"
      />
      <i
        draggable="true"
        data-shape="modelRect"
        class="iconfont icon-model-rect"
      />
    </div>
  </div>
</template>

<script>
  export default {
    name: 'ItemPanel',
    mounted () {
      // 在DOM 加载完毕之后 给每个 物料绑定了 拖拽结束的事件
      this.$refs.itemPanel.querySelector('.icon-tool').addEventListener('dragend', e => {
        if(e.target.classList.contains('iconfont')) {
          // 然后向上父组件 抛出一个事件  
          this.$emit('canvas-add-node', e);
        }
      });

      // 阻止默认动作
      document.addEventListener('drop', e => {
        e.preventDefault();
      }, false);
    },
  };
</script>
```

```vue
<template>
  <div class="root">
    <div id="headPanel">
      <span class="logo">G6 入门教程 - 拖拽节点</span>
      <i class="gb-toggle-btn" />
    </div>
    <!-- 左侧功能栏 -->
    <!-- 1. 拖拽结束之后触发的事件 -->
    <item-panel @canvas-add-node="canvasAddNode" />
    <!-- canvas 挂载节点 -->
    <div id="graph" />
  </div>
</template>

<script>
import G6 from '@antv/g6';
import ItemPanel from './ItemPanel';

export default {
  components: {
    ItemPanel,
  },
  data () {
    return {
      graph:        null,
      canvasOffset: {
        x:  0,
        y:  0,
        dx: 0,
        dy: 0,
      },
    };
  },
  mounted () {
    // 创建画布
    this.$nextTick(() => {
      this.createGraphic();
    });
  },
  beforeDestroy () {
    this.graph.destroy();
  },
  methods: {
    createGraphic () {
      const graph = new G6.Graph({
       ... 初始化了G6
      });

      this.graph = graph;
      this.bindEvents();
    },
    bindEvents() {
     ... 好多代码
    },
    canvasAddNode(e) {
      // 2.   获取了 我们在标签上设置的属性 比如 rect circle ellipse diamond等
      const shape = e.target.getAttribute('data-shape');
	  // 3. 添加节点 后面是属性
      this.graph.addItem('node', {
        label: shape,
        type:  shape,
        // 4.  拿到 鼠标拖拽结束后的坐标 然后就添加了这个节点   this.canvasOffset.dx 是画布的偏移量
        x:     e.clientX - this.canvasOffset.dx - 40,
        y:     e.clientY - this.canvasOffset.dy - 40,
        size:  [120, 40],
      });
    },
  },
};
</script>

```

- 画布移动 偏移量的计算

```js
canvasOffset: {
        x:  0,
        y:  0,
        dx: 0,
        dy: 0,
      },

bindEvents() {
      // 1. 拿到 cavas的DOM 
      const canvas = document.getElementById('graph').children[0];

      // 拖拽开始事件
      this.graph.on('dragstart', e => {
        // 记录鼠标开始拖拽 按下的坐标
        this.canvasOffset.x = e.clientX;
        this.canvasOffset.y = e.clientY;
      });

      // 拖拽结束事件
      this.graph.on('dragend', e => {
        // 结束之后 便宜的坐标就等于 鼠标结束的坐标 减去 鼠标最开始按下的坐标 第一次偏移量肯定是0  
        // 第二次 我们在移动画布的时候 此时已经发生过偏移了 所以我们还需要把原来的偏移量累加上  
        this.canvasOffset.dx = this.canvasOffset.dx + e.clientX - this.canvasOffset.x;
        this.canvasOffset.dy = this.canvasOffset.dy + e.clientY - this.canvasOffset.y;

        canvas.setAttribute('dx', this.canvasOffset.dx);
        canvas.setAttribute('dy', this.canvasOffset.dy);
      });
    },
```



# 节点拖拽放大缩小

## 点击节点 实现放大

- 查看模式下 不可拖拽节点改变大小  编辑模式下才可以

- 这里一共会有三个图形  两个圆角矩形 其中一个圆角矩形会有四个锚点 在编辑模式下 才显示

- 我们实际拖拽的就是这四个锚点 当然也需要绘制出来 拖拽的逻辑 就是监听到 鼠标按下的坐标 和 监听鼠标移动的时 候 坐标的距离 监听鼠标拖拽 抬起 等事件 计算 移动位置的大小

- 有的时候我们移动过快 锚点的转换坐标的速度 跟不上鼠标的速度 所以这个时候我们要加大锚点的边框 确定鼠标移动  的过快 但还是在锚点的范围内

- [x] 点击节点 实现放大

- [x] 初始化图谱

  ```JS
  // 初始化
    const graph = new G6.Graph({
              container: 'container',
              height: window.innerHeight - 40,
              width: window.innerWidth,
        		// 这里使用自定义绘制的节点
              defaultNode: {
                  type: 'my-node',
                  style: {
                      width: 140,
                      height: 40,
                      radius: 4,
                      fill: '#ecf6fc',
                      stroke: '#999',
                  },
                  labelCfg: {
                      style: {
                          fontSize: 14,
                      },
                  },
              },
          })
          graph.read({
              nodes: [{
                  id: '0',
                  x: 350,
                  y: 350,
                  label: 'node',
              }],
          });
  ```

  - [x] 注册自定义节点

  ```js
   G6.registerNode('my-node', {
              draw(cfg, group) {
                  const { label, labelCfg } = cfg
                  // 这里通过 getShapeStyle 方法 拿到的样式 是带节点的位置坐标的 如果你节点坐标没有计算过 
                  const style = this.getShapeStyle(cfg, group)
                  const shape = group.addShape('rect', {
                      attrs: style,
                      name: 'rect-node'
                  })
  
                  group.addShape('text', {
                      attrs: {
                          text: label,
                          fill: '#666',
                          fontSize: 14,
                          x: -16,
                          y: 6,
                      },
                      name: 'node-label'
                  })
  
                  return shape
              },
   },'rect')
  ```

  - [x] 点击节点 更新数据模型 

  ```js
  // 给节点添加 点击事件 默认我们先写 点击节点 自己增加高度和宽度
  graph.on('node:click', (e) => {
      const { item } = e
      // 拿到数据模型
      const model = item.getModel()
      // 给数据模型 让他的宽高 增加
      model.style.width += 2
      model.style.height += 2
      // 拿到数据模型之后 我们去调用updateItem方法 入参有两个 第一个是你节点的实例 第二个是你的数据模型
      graph.updateItem(item, model)
  })
  ```

  - [x]  在update 方法里 更新数据模型 参数有两个 第一个是 的节点上数据模型 第二个是你节点的实例

  ```js
  G6.registerNode('my-node', {
      draw(cfg, group) {
          ... 绘制 节点的代码
          return shape
      },
      update(cfg, item) {
          // 拿到数据模型
          const model = item.getModel()
          // 拿到图
          const group = item.getContainer()
          // 拿到你画的第一个节点
          const node = group.getFirst()
          // 拿到数据模型的宽高
          const { width, height } = model.style
          // 更新节点
          node.attr({
              width,
              height,
              // 这里为了让节点 是以中心 放大 所以 要 在节点更新的同时 还要 重新计算坐标
              x: -width / 2,
              y: -height / 2,
          })
      }
  }, 'rect')
  ```

## 切换模式显示隐藏图形

- 我们在注册自定义的节点的时候 回画两个矩形 其中一个矩形 会有四个锚点 默认情况下 visible 是 false也就是隐藏的
- 当我们切换 查看或者编辑按钮的时候 会调用 setItemState 方法 去更新的状态 该方法 入参有三个 第一个是你的节点实例 第二个 是你的自定义的状态的名称 第三个 是你的 状态的值
- 调用setItemState 方法之后 就会走到我们 自定义节点的 setState方法里 该方法形参 有三个 第一个是 的自定义状态的名称 第二个是你的状态值 第三个 是实例本身

- [x] 绘制 图形和锚点

```js
// 锚点 我们是循环绘制的 
const addControlPoint = [
        {
            name: 'top-point', 
            fill: '#1890ff', 
            r: 4,  
            stroke: '#fff',
            strokeOpacity: 0,
            lineWidth: 20,
            visible: false, 
            className: 'control-point',
            cursor:        'ns-resize',
        },
        {
            name: 'right-point', 
            fill: '#1890ff', 
            r: 4,  
            stroke: '#fff',
            strokeOpacity: 0,
            lineWidth: 20,
            visible: false, 
            className: 'control-point',
            cursor:        'ew-resize',
        },
        {
            name: 'bottom-point', 
            fill: '#1890ff', 
            r: 4,  
            stroke: '#fff',
            strokeOpacity: 0,
            lineWidth: 20,
            visible: false, 
            className: 'control-point',
            cursor:        'ns-resize',
        },
        {
            name: 'left-point', 
            fill: '#1890ff', 
            r: 4,  
            stroke: '#fff',
            strokeOpacity: 0,
            lineWidth: 20,
            visible: false, 
            className: 'control-point',
            cursor:        'ew-resize',
        }
    ]
```

```js
G6.registerNode('my-node', {
            draw(cfg, group) {
                const { label, labelCfg } = cfg
                // 这里通过 getShapeStyle 方法 拿到的样式 是带节点的位置坐标的
                const style = this.getShapeStyle(cfg, group)
                // 绘制第一个 圆角矩形
                const shape = group.addShape('rect', {
                    attrs: style,
                    name: 'rect-node'
                })
			   // 绘制文本
                group.addShape('text', {
                    attrs: {
                        text: label,
                        fill: '#666',
                        fontSize: 14,
                        x: -16,
                        y: 6,
                    },
                    name: 'node-label'
                })
                // 绘制第二个矩形 由于是 第二个绘制的 所以会在第一个下面
                group.addShape('rect', {
                    attrs: {
                        ...style,
                        radius: 4,
                        fill: 'red',
                        stroke: 'blue',
                        fillOpacity: 0.7,
                    },
                    // 我们设置默认隐藏
                    visible: false,
                    className: 'rect-node-shadow',
                })
			   // 开始绘制 上 右 下 左 四个锚点 坐标需要根据矩形的宽高计算
                addControlPoint.forEach( item => {
                    switch (item.name) {
                        case 'top-point':
                            item.x = 0,
                            item.y = - style.height / 2
                            break;
                        case 'bottom-point':
                            item.x = 0,
                            item.y = style.height / 2
                            break;
                        case 'left-point':
                            item.x = -style.width / 2,
                            item.y = 0
                            break;   
                        case 'right-point':
                            item.x = style.width / 2,
                            item.y = 0
                            break;      
                        default:
                            break;
                    }
                    // 循环绘制 四个锚点
                    group.addShape('circle', {
                        attrs: {
                            r:             item.r,
                            fill:          item.fill,
                            stroke:        item.stroke,
                            strokeOpacity: 0,
                            lineWidth:     20,
                            x:             item.x,
                            y:             item.y,
                            cursor:        item.cursor,
                        },
                    visible: item.visible,
                    className: item.className,
                    name:item.name
                })
                })
                return shape
            },
            update(cfg, item) {
              ... 这里实现了 点击节点 自己增大
            },
            setState(name, value, item) {
             ... 这里是切换状态的逻辑
            }
        }, 'rect')
```

- [x] 点击按钮切换状态 调用 setItemState 方法

```js
// 拿到按钮DOM
const btn = document.getElementById('btn')
// 给按钮监听事件
btn.addEventListener('click', changeModel)
// 获取到了所有的节点实例
const nodes = graph.getNodes()
function changeModel() {
    console.log(nodes, '==nodes')
    // 切换状态
    if (this.innerText === '查看') {
        this.innerText = '编辑'
        modelStatu = 'edit'
        // 开始设置状态 因为我们页面上 只有一个节点 所以 这里我们指取第0个
        graph.setItemState(nodes[0], 'changeModel', modelStatu)
    } else {
        this.innerText = '查看'
        modelStatu = 'view'
        graph.setItemState(nodes[0], 'changeModel', modelStatu)
    }
}
```

- [x] 在 setState 方法里 去更新 节点的隐藏 或者显示

```js
G6.registerNode('my-node', {
            draw(cfg, group) {
            	... 绘制自定义节点的逻辑
                return shape
            },
            update(cfg, item) {
              ... 点击节点 宽高增加的逻辑
            },
            setState(name, value, item) {
                // 这里就是你的 状态的名称 状态的值  和 节点的实例本身
                console.log(name, value, item)
                // 拿到图谱
                const group = item.getContainer()
                // 看看 你绘画了 几个自定义节点
                const children = group.getChildren()
                console.log(children, '==children');
                // 看看是不是我们的 要要的 那几个节点 因为我们都定义了className
                children.forEach(item => {
                    if (item.cfg.className === 'rect-node-shadow' || item.cfg.className === 'control-point') {
                        if (value === 'edit') {
                            // 调取节点实例的 显示 或者隐藏的方法
                            item.show()
                        } else {
                            item.hide()
                        }
                    }
                })
            }
        }, 'rect')
```

## 拖拽锚点实现节点方法

- 首先鼠标会监听按下 移动 抬起 离开的事件 当鼠标按下的时候 就开始计算 坐标 并且 调取 updateItem 函数
- 在 **updateItem** 函数里 我们需要 调整锚点的位置 和 节点形状的大小 
- 这里我们用自定义行为去写 里面集成了 鼠标按下 移动 抬起 离开 等四个事件

- [x] 注册自定义行为

```js
// 鼠标按下的时候 坐标
const startPos = {
            x: 0,
            y: 0
        }
//  鼠标按下事的锚点名称
const dwonCurrent = {
    node:null,
}

G6.registerBehavior('node-drag', {
        getEvents() {
            return {
                'node:mousedown': 'onMouseDown',
                'node:mousemove': 'onMousemove',
                'node:mouseup': 'onMouseup',
                'node:mouseleave': 'onMouseleave'
            }
        },
        draggble: false,
    	// 鼠标按下 看看 是不是编辑状态  记录下坐标  并根据target.cfg.name 记录 点击的是哪个锚点 记录起始坐标
        onMouseDown(e) {
            if (modelStatu === 'edit' && !this.dragging) {
                const { x, y ,target} = e
                dwonCurrent.node = target.cfg.name
                startPos.x = x
                startPos.y = y
                this.draggble = true
            }
        },
       // 开始移动鼠标 计算鼠标移动的距离 然后 传递给 updateSize 来 更新 节点的大小
        onMousemove(e) {
            if (this.draggble && modelStatu === 'edit') {
                const { x, y } = e
                const dx = startPos.x > x ? startPos.x - x : x - startPos.x
                const dy = startPos.y > y ? startPos.y - y : y - startPos.y
                startPos.x = x
                startPos.y = y
                updateSize(e, x,y,dx, dy)
            }
        },
    	// 鼠标抬起 结束拖拽状态
        onMouseup() {
            if (this.draggble && modelStatu === 'edit') {
                this.draggble = false
            }

        },
        // 鼠标离开 结束拖拽状态
        onMouseleave() {
            if (this.draggble && modelStatu === 'edit') {
                this.draggble = false
            }
        }
})


```

- [x] 在配置项 使用 自定义 行为

```js
const graph = new G6.Graph({
    ... 好多配置项目的代码
    // 下面使用 自定义行为
    modes: {
        default: ['node-drag']
    }
})
```

- [x] 节点宽度高度 方法 或者做小

```js

// 当我们 鼠标移动的时候调取的就是这个函数

// x y 是鼠标移动的的坐标 
// dx dy 是鼠标移动的时候减去 鼠标按下的距离 也就是 宽度高度增加的大小
function updateSize(e, x,y,dx, dy) {
    const { item } = e
    const model = item.getModel()
    // 这里我们需要判断 你点击的是哪个锚点  然后在根据 你是上移动 还是下移动来 确定 你是放大还是缩小
    switch (dwonCurrent.node) {
        case 'top-point':
            if(y - startPos.y > 0 ) {
                model.style.width -= dx
                model.style.height -= dy
            }else{
                model.style.width += dx
                model.style.height += dy
            }
            break;
            case 'bottom-point':
            if(y - startPos.y < 0 ) {
                model.style.width -= dx
                model.style.height -= dy
            }else{
                model.style.width += dx 
                model.style.height += dy
            }
            break;
            case 'left-point':
            if(x - startPos.x > 0 ) {
                model.style.width -= dx
                model.style.height -= dy
            }else{
                model.style.width += dx
                model.style.height += dy
            }
            break;
            case 'right-point':
            if(x - startPos.x < 0 ) {
                model.style.width -= dx
                model.style.height -= dy
            }else{
                model.style.width += dx
                model.style.height += dy
            }
            break;
        default:
            break;
    }
	// 最后 更新的我们的节点 和我们的数据模型 就走到我们自定义节点的 update 函数里
    graph.updateItem(item, model)
}
```

- [x] update 函数

```js
G6.registerNode('my-node', {
    draw(cfg, group) {
      	... 好多代码
        return shape
    },
    update(cfg, item) {
        // 拿到数据模型
        const model = item.getModel()
        // 拿到图
        const group = item.getContainer()
        const children = group.getChildren()
        // 拿到你画的第一个节点
        const node = group.getFirst()
        // 拿到数据模型的宽高
        const { width, height } = model.style
        // 更新节点
        node.attr({
            width,
            height,
            x: -width / 2,
            y: -height / 2,
        })
        children.forEach(child => {
            // 这里是我们编辑状态下的 那个 阴影的圆角矩形
            if (child.cfg.className === 'rect-node-shadow') {
                child.attr({
                    width,
                    height,
                    x: -width / 2,
                    y: -height / 2,
                })
            } else if (child.cfg.className === 'control-point') {
                // 这里要重新更新锚点的位置
                switch (child.cfg.name) {
                    case 'top-point':
                        child.attr({ y: -height / 2 });
                        break;
                    case 'right-point':
                        child.attr({ x: width / 2 });
                        break;
                    case 'bottom-point':
                        child.attr({ y: height / 2 });
                        break;
                    case 'left-point':
                        child.attr({ x: -width / 2 });
                        break;
                }
            }
        })
    },
    setState(name, value, item) {
      ... 编辑状态下 锚点隐藏 和 显示逻辑
    }
}, 'rect')
```

# 自定义图标节点

- 节点旁边和里面会有图标
- 点击成功的时候 切换到 失败状态 然后点击失败切换到成功状态
- 图标根据上面的状态切换也会变换相关的颜色

## 绘制图标

### 初始化画布和数据

```js
const graph = new G6.Graph({
    container: 'container',
    width: window.innerWidth - 40,
    height: window.innerHeight - 40,
    defaultNode: {
        type: 'rect',
        style: {
            width: 100,
            height: 30,
            radius: 4,
            fill: '#fff',
            stroke: '#ccc',
        },
        labelCfg: {
            style: {
                fontSize: 14,
            },
        },
    },
});
// 初始画数据 这里节点我们给0
graph.read({
    nodes: [{
        id: '0',
        x: 350,
        y: 350,
        label: 'node1',
    }],
});
```

### 通过id找到节点实例 拿到图谱 绘制字体图标

```js
// 通过id 查找到节点实例
const item = graph.findById('0')
// 拿到图谱
const group = item.getContainer()
// 开始绘制
const icon = group.addShape('text', {
    attrs: {
        // 这里要跟我们的 字体图标文件 的字体保持一致
        fontFamily: 'graphicon',
        // 这里我们用的时候 一定要加个u 才可以生效 比如字体图标编码是 \e6a5 要变成 \ue6a5 才能生效
        text: '\ue6a5',
        fill: '#1890ff',
        fontSize: 30,
        x: -54,
        y: 15,
    }
})
// 绘制第二个字体图标
const icon2 = group.addShape('text', {
    attrs: {
        fontFamily: 'graphicon',
        text: '\ue6a5',
        fill: '#ce4c4c',
        fontSize: 16,
        x: 60,
        y: 7,
    },
    name: 'state',
});
```

### 切换成功失败状态 切换图标

```js
let modelStatu = '失败'
const btn = document.getElementById('btn')
btn.addEventListener('click', changeModel)

function  getGraph () {
    // 找到 节点
    const item = graph.findById('0')
    // 拿到节点图谱
    const group = item.getContainer()
    // 获取图谱下所有的元素
    const children = group.getChildren()
    // 找到你要切换状态的元素
    const stateIcon = children.find(child => child.cfg.name ==='state')
    return stateIcon
}
let iconItem = getGraph()
function changeModel() {
    if (this.innerText === '失败') {
        this.innerText = '成功'
        modelStatu = 'success'
	    // 调用 attr方法 设置元素的样式
        iconItem.attr({
            fill: 'green',
        })
    } else if (this.innerText === '成功') {
        this.innerText = '失败'
        modelStatu = 'error'
        iconItem.attr({
            fill: 'red',
        })
    }
}
```

## 自定义图片

### 场景

```markdown
1. 左侧的图片栏目 可以拖拽到画布当中
2. 点击编辑的时候 可以让图片放大缩小
3. 点击确定 画布中的节点 变成缩放的大小
```

### 拖拽

- html结构

```HTML
左侧侧边栏的结构
<div id="dv" class="node-panel">
    <img src="./images/1.png" />
    <img src="./images/2.png" />
    <img src="./images/3.png" />
    <img src="./images/0.jpg" />
</div>
```

- 逻辑

```markdown
1.  给每个图片绑定 dragstart 拖拽开始事件
2.  把图片的信息 比如 图片的src路径 原始 图片的大小 设置在 event.dataTransfer
3. 因为是拖拽到画布上 所以 画布监听 拖拽松手事件 获取 设置 在 event.dataTransfer 的数据
4. 在 画布中创建节点 设置我们拖拽的信息
```

- 代码

- [x] 初始化画布

```js
// 初始化 画布

const graph = new G6.Graph({
    container: document.getElementById('graph'),
    width: window.innerWidth,
    height: window.innerHeight -40,
    defaultNode: {
        type: 'rect',
        style: {
            width: 100,
            height: 30,
            radius: 4,
            fill: '#f1f1f1',
            stroke: '#ccc',
        },
        labelCfg: {
            style: {
                fontSize: 14,
            },
        },
    },
    layout: {
        type: 'xxx',
    },
    modes: {
        default: ['drag-node', 'drag-canvas'],
    },
    plugins: [grid, menu], // 添加 邮件菜单 和 宫格插件
});
```

- [x] 左侧绑定 dragstart 事件 并设置数据

```js
const dv = document.getElementById('dv')
// 获取左侧所有的 图片DOM
const images = dv.querySelectorAll('img')
Array.from(images).forEach(item => {
    item.addEventListener('dragstart', (e) => {
        // 拿到图片的引用地址 和 图片的原始宽高 就是图片的真是宽高
        const { src, naturalWidth, naturalHeight } = event.target;
        // 拿到图片的 宽高比例
        imgHTML.scale = naturalWidth / naturalHeight
        // 当鼠标放下之后 设置一下数据
        event.dataTransfer.setData('img', JSON.stringify({
            src,
            width: naturalWidth,
            height: naturalHeight,
        }));
    })
})
```

- [x] 画布监听拖拽松手事件 并添加元素 绘制图片图

```js
graph.on('drop', event => {
    // 拿到鼠标松开的 的时候 坐标 和 最原始的事件对象 dataTransfer 上面有我们设置的 数据
    const { clientX, clientY, originalEvent: { dataTransfer } } = event;
    // 先阻止默认行为
    event.stopPropagation()
    // 添加一个节点
    if (dataTransfer) {
        // 获取我们拖拽的时候 设置的对象 因为我们保存为字符串了 
        const data = dataTransfer.getData('img');
        if (data) {
            // 这里需要转换为 对象
            const { src, width, height } = JSON.parse(data);
            // 清楚 我们设置的数据
            dataTransfer.clearData();
            // 创建一个节点类型元素 坐标就是 我们鼠标松手的地方 宽高就是我们图片原始的大小的宽高
            const node = graph.addItem('node', {
                x: clientX ,
                y: clientY,
                style: {
                    width, 
                    height,
                    // fill: 'red',
                    strokeOpacity: 0,
                    fillOpacity: 0
                }
            })
            // 获取图谱 
            const group = node.getContainer()
            // 绘制一个img类型节点 这里的坐标 是相对于节点元素来说的
            group.addShape('image', {
                attrs: {
                    x: -width / 2,
                    y: -height / 2,
                    img: src,
                },
                name: 'img',
                draggable: true,
            })
        }
    }
});
```

### 编辑

- 逻辑

```markdown
1. 因为我们用了右键菜单的插件 所以点击编辑的时候 可以拿到 节点的实例
2. 就可以得到 实例上的 宽高 和 距离画布的 上 左距离
3. 然后让节点实例隐藏 我们的 html元素显示
4. html 元素 里面有 图片 然后把我们设置的 节点的数据 给HTML 即可
```

- 代码

- [x]  右键插件

```js
// 插件配置
// 插件的方法
let rightMenu = {
    editLayer,
    toFront,
    toBack
}
const menu = new G6.Menu({
    itemTypes: ['node'],
    getContent(e) {
        return `<p command="editLayer">编辑图层</p>
    <p command="toFront">置于顶层</p>
    <p command="toBack">置于底层</p>
  `;
    },
    handleMenuClick(target, item) {
        const command = target.getAttribute('command');
        rightMenu[command] && rightMenu[command](item,target)

    },
});
```

- [x] 编辑按钮

- 逻辑

```markdown
1. 拿到节点实例 获取 宽高 和 上 左距离 这里注意我们获取的是 节点实例相对于 画布的 上 左距离
2. 隐藏节点实例 显示 HTML结构 把获取的数据设置给HTML结构
```

- 代码

```HTML
<div id="image-edit" style="display: none;">
    <img style="width: 100%;height: 100%;" src=""></img>
    <i class="img-editor-bar bar-top" mousedown="dragstartbar" mousemove="dragbar" mouseup="dragendbar"></i>
    <i class="img-editor-bar bar-left" mousedown="dragstartbar" mousemove="dragbar" mouseup="dragendbar"></i>
    <i class="img-editor-bar bar-right" mousedown="dragstartbar" mousemove="dragbar" mouseup="dragendbar"></i>
    <i class="img-editor-bar bar-bottom" mousedown="dragstartbar" mousemove="dragbar" mouseup="dragendbar"></i>
    <div style="position: absolute;bottom: -40px;right: 0;">
        <button class="btn confirm">
            确定
        </button>
        <button class="btn cancel">
            取消
        </button>
    </div>
</div>

i 标签 是控制点
```

- 代码

```js
// 拿到 HTML DOM
const editBox = document.getElementById('image-edit')
// 拿到 img DOM
const imgShow = editBox.querySelector('img')
const cancel = document.querySelector('.cancel')
const confirm = document.querySelector('.confirm')
// 编辑的节点实例ID
const currentNode = {
    id: null
}
// 点击编辑
function editLayer(e,target) {
    // 每次编辑之前 清楚 一下事件
    addEvent()
    // 这里的 e 是 节点实例
    // 拿到图谱
    const group = e.getContainer()
    // 看到图谱下的有几个图形
    const children = group.getChildren()       
    // 找到 为img 的图形 这里我们在拖拽的时候 添加节点 添加上去的
    const img = children.find(item => item.cfg.name === 'img')
    // 获取节点实例的 id
    const {id} = e.getModel()
    // 设置为当前id
    currentNode.id = id
    // 这里 拿到 图片图形的 src地址 和 宽高 这里需要注意 我们点击确定的时候 没有设置节点的数据模型所以要用图形的数据模型
    const { img: image, width, height } = img.attrs;
    // 拿到了 元素 对于画布的坐标 
    const {x,y} = img.cfg.canvasBBox
    if (img) {
        // 隐藏 节点实例
        graph.hideItem(e);
        // 设置 节点的宽高 和位置 并让HTML元素显示
        editBox.style.cssText = `display:block;width:${width}px;height:${height}px;top:${y + 40}px;left:${x}px;`
        // 设置图片 的地址 
        imgShow.src = image.src;
    }
}

// 以上 我们的图形 就用HTML元素显示了出来 可以拖拽  html上的锚点 来事件 放大和缩小
```

### 放大缩小

- 逻辑

```markdown
1. 监听 HTML i 标签的 鼠标 按下 移动 和 抬起
2. 记录 鼠标的坐标
3. 然后 计算图片的宽高和距离 实现方法和缩小 
```

- 代码

- [x] 监听i标签的 鼠标按下 移动 和抬起事件

```js
function addEvent() {
    Array.from(pointer).forEach(item => {
        item.addEventListener('mousedown', mousedown)
        item.addEventListener('mousemove', mousemove)
        item.addEventListener('mouseup', mouseup)
        item.addEventListener('mouseleave', mouseleave)
    })
}
```

- [x] 鼠标按下

```markdown
1. 设置可以拖拽开关
2. 记录坐标
```

```js
// 记录鼠标坐标
const offset = {
    x: null,
    y: null,

}
let drag = false
function mousedown(e) {
    drag = true
    // 记录 鼠标按下的坐标
    const { clientX, clientY } = e
    offset.x = clientX
    offset.y = clientY
}
```

- [x] 鼠标移动

```markdown
1. 计算鼠标移动的距离
2. 计算HTML 图片 放大 或者缩小 还有 上 左的距离
```

```js
function mousemove(e) {
    if (drag) {
        // 计算鼠标 移动的 和开始的距离
        const distance = {
            x: e.clientX - offset.x,
            y: e.clientY - offset.y
        }
        offset.x = e.clientX
        offset.y = e.clientY
        let width = editBox.offsetWidth
        let height = editBox.offsetHeight
        let top = editBox.offsetTop
        let left = editBox.offsetLeft
        // 让图片的宽度 逐步增加
        width += distance.x * 2

        if (distance.y === 0) {
            // 因为这里我们 已经提前算过 宽高比了 所以当我们拖拽增加款图的时候 让高度也增加即可
            // 这里 只设置了 增宽的时候 高度也自动按比例增加 而高度没有 逻辑相同
            height += distance.x * 2 / imgHTML.scale
            // 计算高度的坐标
            top -= distance.x / imgHTML.scale
            // 给图片设置 宽高 
            editBox.style.width = `${width}px`
            editBox.style.height = `${height}px`
            editBox.style.top = `${top}px`
        } else {
            height += distance.y * 2
            top -= distance.y
            editBox.style.height = `${height}px`
            editBox.style.top = `${top}px`
        }
        // 最后 设置 左侧距离
        left -= distance.x
        editBox.style.left = `${left}px`
    }
}
```

### 确定

- 逻辑

```markdown
1. 点击确定 拿到节点的时候 显示节点 隐藏 HTML 元素
2. 拿到 HTML元素的 宽高 这里 已经被缩放过了
3. 把拿到的 HTML 元素的宽高 和 上 左距离 设置给我们的图谱 这里我们没有设置给节点实例 如果需要可以 条用updateItem 去更新节点实例的数据模型
```

- 代码

```js
confirm.addEventListener('click', () => {
    // 通过 id 找到我们的节点实例
    const node = graph.findById(currentNode.id)
    // 获取图谱
    const group = node.getContainer()
    // 获取图谱下的图形
    const children = group.getChildren()
    // 里面主要有一个矩形图形 和图片图形
    const item = group.getFirst();
    const img = children.find(item => item.cfg.name === 'img')
    // 拿到 HTML元素的宽高 和 
    const model = {
        width: editBox.offsetWidth,
        height: editBox.offsetHeight,
        x: -editBox.offsetWidth / 2,
        y: -editBox.offsetHeight / 2
    }
    // 让HTML 元素隐藏
    editBox.style.display = 'none'
    // 设置 图形的数据 更改为 HTML 放大或者缩小后的 数据
    item.attr(model)
    img.attr(model)
    // 显示 节点实例
    graph.showItem(node)
    removeEvent()
})
```

### 置顶 置底

- 逻辑

```markdown
1. 右键菜单 提供 置顶 置底按钮
2. 拿到节点实例 调用 方法
```

- 代码

```js
 // 点击置顶
function toFront(e) {
    e.toFront()
}
// 点击置底
function toBack(e) {
    e.toBack()
}
```

## 小结

```js
1. 我们初步可以理解 节点实例 下面 有图谱 图谱下面有图形
2. 可以通过节点实例 获取到 数据模型 获取到 图谱 在通过图谱获取到下面的图形
3. 更新节点数据 就调用 updateItem 方法 更新 图形数据 就需要找到图形 调用attr方法
4. 节点的 坐标 是以节点中心为计算的
```

## 链表查询

### 需求

```markdown
1. 每个节点都是一张表 上面有表明 和 表的字段 
2. 如果是父节点 右侧 有会有加号按钮 点击之后可以看到子节点
3. 如果当前节点 即是父节点 又是子节点 那么两侧都会有加号按钮 点击 可以看到自己的子节点 和 父节点
4. 点击当前节点 可以显示下拉框 用来显示 表里面的字段
```

### 数据结构

```JS
const data = {
    nodes: [{
        id: '0',
        x: 200,
        y: 250,
        label: 'user_info',
        text: 'security_setup',
        data: {
            expand: false, // 下拉框是否展开
            show: false, // 当前节点是显示还是隐藏
            childId: '1', // 子节点的id
        },
    }, {
        id: '1',
        x: 500,
        y: 200,
        label: 'personal_info',
        text: 'some_things',
        data: {
            expand: false, // 下拉框是否展开
            show: true,
            parentId: '0',
            childId: '2',
        },
    }, {
        id: '2',
        x: 800,
        y: 250,
        label: 'friends_relation',
        text: 'some_friend',
        data: {
            expand: false, // 下拉框是否展开
            show: false,
            parentId: '1',
        },
    }],
    // 边的连线
    edges: [{
        target: '0',
        source: '1',
    }, {
        target: '1',
        source: '2',
    }],
};
```

### 画布初始化

```js
const graph = new G6.Graph({
    container: document.getElementById('graph'),
    width: window.innerWidth,
    height: window.innerHeight - 40,
    defaultNode: {
        type: 'rect',
        style: {
            width: 200,
            height: 50,
            radius: 4,
            fill: '#5cbc5a',
            stroke: '#5cbc5a',
        },
        labelCfg: {
            style: {
                fontSize: 14,
                fill: '#fff',
            },
        },
    },
    layout: {
        // type: 'xxx',
    },
    defaultEdge: {
        type: 'cubic-horizontal',
    },
    modes: {
        default: ['drag-node', 'drag-canvas'],
    },
    plugins: [grid],
});
graph.read(data)
```

### 绘制节点

```markdown
1. 节点上面是绿色的 下面是白色的
2. 如果是父亲节点 那么右侧显示 加号
3. 如果即使父亲节点 又是子节点 那么两侧都有
4. 我们要获取所有节点实例 然后循环绘制
```

- 代码

```js
// 拿到所有节点实例 这里我们本身的节点下面会有两个图行 一个是开始的矩形 一个是文字
const nodes = graph.getNodes()
nodes.forEach(item => {
    // 拿到每个节点的数据模型
    const model = item.getModel()
    // 获取图谱
    const group = item.getContainer()
    // 获取所有图形
    const children = group.getChildren()
    // 获取节点上挂在的数据
    const { childId, parentId, show } = model.data;
    // 调节我们最开始的文本位置
    children[1].attr({
        textAlign: 'left',
        x: -70,
        y: -12
    })
    // 然后画下面的白色矩形 并且给大设置className 方便我们点击的时候做判断
    group.addShape('rect', {
        attrs: {
            width: 198,
            height: 24,
            fill: '#fff',
            x: -99,
            cursor: 'pointer',
        },
        className: 'select-btn',
    })
    // 绘制 下面白色矩形的文字
    group.addShape('text', {
        attrs: {
            text: model.text,
            fill: '#666',
            x: -80,
            y: 16,
            cursor: 'pointer',
        },
        className: 'select-btn',
    });
    // 和下拉的按钮
    group.addShape('text', {
        attrs: {
            x: 80,
            y: 20,
            text: '^',
            fill: '#666',
        },
        className: 'select-icon'
    });
	// 看看 你是不是子节点 如果是 绘制左侧按钮
    if (parentId) {
        /* body-icon-before */
        group.addShape('circle', {
            attrs: {
                r: 5,
                fill: '#666',
                cursor: 'pointer',
                x: -100,
                y: 10,
            },
            name: 'icon-before',
            className: 'icon-before',
        });
        // 按钮中间的 + 号用来显示 展开或者收起
        /* body-icon-text */
        group.addShape('text', {
            attrs: {
                text: '+',
                fill: '#fff',
                cursor: 'pointer',
                x: -104,
                y: 15,
            },
            name: 'icon-before-text',
            className: 'icon-before',
        });
    }
    // 看看 你是不是父节点 如果是 绘制右侧的 拓展按钮 用来 展开或者收起 子节点
    if (childId) {
        /* body-icon-after */
        group.addShape('circle', {
            attrs: {
                r: 5,
                fill: '#666',
                cursor: 'pointer',
                x: 100,
                y: 10,
            },
            name: 'icon-after',
            className: 'icon-after',
        });
        /* body-icon-text */
        group.addShape('text', {
            attrs: {
                text: '+',
                fill: '#fff',
                cursor: 'pointer',
                x: 96,
                y: 15,
            },
            name: 'icon-after-text',
            className: 'icon-after',
        });
    }
    //  看看 你当前节点是不是隐藏的 如果是 就隐藏
    if (!show) {
        graph.hideItem(item);
    }
})
```

### 点击展开 或者 收缩 子节点 或 父节点

- 逻辑

```markdown
1. 首先给节点注册点击 事件 然后我们可以拿到 他的className 如果是我们绘制的拓展节点 我们就做对应的逻辑处理
2. 首先要拿到当前点击节点的id 这个节点数据里 有自己子节点id 然后通过子节点id 找到子节点实例
3. 然后调用 子节点实例的方法 isVisible() 看看 是隐藏还是显示的 
4. 如是显示 就把他隐藏 调用 hideItem() 隐藏就把他显示 showItem()
5. 最后在通过 name 属性 找到 我们的拓展按钮 如果是 + 就变成 - 如果是减 就变成+
```

- 代码

```js
graph.on('node:click', e => {
    // 注册点击事件
    const { item, target: { cfg: { className } } } = e
    const model = item.getModel()
    // 看看点击的是节点上的哪个图形 做相应的逻辑处理 
    if (className) {
        switch (className) {
            case 'icon-before':
                expandParent(item, model) // 展开 和收起
                break
            case 'icon-after':
                expandChild(item, model)
                break
            case 'select-btn':
                selectOption(item, model)
                break
            default:
                break
        }
    }
})
```

```js
function expandChild(item, model) {
    // 拿到当前子节点的id
    const { id, data: { childId } } = model
    const children = item.getContainer().getChildren()
    // 找到拓展按钮的图形
    const iconText = children.find(child => child.cfg.name === 'icon-after-text');
    if (childId) {
        // 找到子节点的实例
        const child = graph.findById(childId);
        // 查看显示或者隐藏的状态
        console.log(child.isVisible());
        if (child.isVisible()) {
            // 如果是显示 就变成+
            iconText.attr({
                text: '+'
            })
            // 并且隐藏这个节点 注意 这里 跟节点有关系的线也会隐藏 而调用 节点实例本身 show 和 hide 方法只会隐藏节点
            graph.hideItem(child)

        } else {
            // 同上面逻辑相反
            iconText.attr({
                text: '-'
            })
            graph.showItem(child)
        }
    }
}
```

### 点击节点下面白色区域 弹出或收起下拉框

- 逻辑

```markdown
1. 可以拿到当前节点的数据模型 可以拿到 节点的 宽高坐标
2. 给我们的HTML元素 设置 定位 和 宽高
```

- 代码

```js
// 点击节点事件 参考上面的 收缩 或者展开
const box = document.getElementById('optionBox')

const ul = document.createElement('ul')
function selectOption(item, model) {
	// 拿到图谱
    const group = item.getContainer()
    const children = group.getChildren()
    // 找到我们的 上 下箭头
    const selectBtn = children.find(item => item.cfg.className === 'select-icon')
    const { x, y, style: { width, height } } = model
    // 看看 给当前状态取反
    model.data.expand = !model.data.expand
    // 去数据里找到当前下拉选线
    const options = model.id
    if (model.data.expand) {
        //如果当前下拉是显示 设置HTML的 宽高 和 位置
        box.style.display = 'block'
        box.style.top = y + 40 + height / 2 + 'px'
        box.style.left = (x - width / 2) + 'px'
        selectBtn.attr({
            text: '⏷'
        })
        selections[options].forEach(item => {
            ul.innerHTML += `<li style="padding:5px" data-value="${item.value}}">${item.label}</li>`
        })

        box.appendChild(ul)
    } else {
        // 反之就隐藏
        box.style.display = 'none'
        ul.innerHTML = ''
        box.removeChild(ul)
        selectBtn.attr({
            text: '^'
        })
    }
}
```

## 技能树脑图

### 需求描述

```markdown
1. 首先根据数据渲染出对应的 脑图 根节点 是有 背景颜色的 每个子节点上面 前面 会有 图标 后面会有 圆角矩形 标注自己点的数量
2. 有展开和收缩功能 可以自动计算 节点层级之间的关系 
3. 布局有两种 脑图布局 和 文件系统布局 通过 单选按钮切换
4. 右键菜单 有增加节点 删除节点 和 作为根节点查看 等功能
5. 编辑模式下 可以点击节点 右侧弹出框 上面有 节点的文字信息 可以更改
6. 可以通过 多选框 选择节点 然后视图显示当前选中的节点 作为根节点 
7. 有缩略图 有右侧bar 方法 缩小 1比1 显示等按钮
```

### 初始化

- 逻辑

```markdown
1. 会在window 上挂在一个对象 createGraph 
2. 这个对象里 写了初始化的方法
3. 这里我们用了 jq
4. 初始化的配置 都写在 create-graph.js里
```

- 代码

```js
$(function () {
    window.createGraph = {
    init({ isAdmin }) { ...初始化代码  }
    initGraph () {  ... 实例化G6  },
    createMenu () { ... 实例化右键菜单插件   },
    createTooltip () {  ... 实例化 tooltip 鼠标悬停插件  },
    createToolbar() { ... 实例化右侧 方法缩小 1：1插件   },
    registerNode() { ...自定义几点的方法    },
    registerEdge() {  ... 自定义边的方法    }
})
```

### createGraph.init

- 逻辑

```markdown
1.  调用了 initGraph 方法 实例了G6
2.  导出了一些配置项 比如 布局的配置 按钮的配置等
```

- 代码

```js
$(function () {
  // 实例的 g6
  let treeGraph;
  // 引入 脑图的类 宫格的插件 右键按钮的插件 提示的插件 工具的插件 小地图的插件 工具类 自定义节点 和 字鼎边方法  
  const { TreeGraph, Grid, Menu, Tooltip, ToolBar, Minimap, Util, registerNode, registerEdge } = window.G6;
  // 先在缓存里看看 你存放的是 脑图的布局 还是 文件系统的布局  
  const layoutType = window.localStorage.getItem('graph-layout-type') || 'mindmap'; 
  // 一些 设置坐标的时候 用到的变量  	
  const baseConfig = {
    nodePaddingLeft:  10,
    nodePaddingRight: 10,
    nameFontSize:     12,
    childCountWidth:  22,
    countMarginLeft:  10,
    nodeMinWidth:     50,
  };
  // 脑图布局的配置 别入 节点和节点之间的宽度 或者 节点和节点之间的高度	
  const commonConfig = {
    getHeight() {
      return 16;
    },
    // 这里节点和几点之间的宽度 我们通过 节点的文字 计算出来的 方便 连线的贝塞尔好看一些  
    getWidth(d) {
      const labelWidth = Util.getTextSize(d.label, baseConfig.nameFontSize)[0];
      const width =
        baseConfig.nodePaddingLeft + labelWidth + baseConfig.childCountWidth + baseConfig.nodePaddingRight;

      return width;
    },
    // 横向的比例  
    getVGap() {
      return 15;
    },
    // 纵向的比例  
    getHGap() {
      return 30;
    },
  };
  // 这里就是 布局了  有脑图的 还有文件系统的 当我们 点击单选更换布局的时候 就切换这两个数据就可以了	
  const graphLayout = {
    mindmap: {
      config: {
        ...commonConfig,
        type:      'mindmap',
        direction: 'H',
      },
      edgeType: 'smooth-edge',
    },
    indented: {
      config: {
        ...commonConfig,
        type:         'indented',
        isHorizontal: true,
        direction:    'LR',
        indent:       30,
      },
      edgeType: 'step-line',
    },
  };
    
    window.createGraph = {
    init({ isAdmin }) { 
    
    }
	... 好多代码
})
```

### createGraph.initGraph实例化G6

- 逻辑

```markdown
1. 就是正常 实例化的逻辑 加载了一些插件之类的
```

- 代码 

```js
initGraph () {
      // 缓存this
      const _this = this;
      // 拿到 DOM
      const container = $('#graph-container')[0];
      // 实例化宫格插件
      const grid = new Grid();
      // 实例化 小地图插件
      const minimap = new Minimap({
        size: [200, 150],
      });
      // 实例化 右键菜单
      const menu = _this.createMenu();
      // 实例化 tooltip提示
      const tooltip = _this.createTooltip();
      // 实例化 工具
      const toolbar = _this.createToolbar();

      // 注册自定义节点
      _this.registerNode();
      // 注册自定义边
      _this.registerEdge();

      treeGraph = new TreeGraph({
        container,
        width:       container.offsetWidth,
        height:      container.offsetHeight,
        // 用 自定义的节点  
        defaultNode: {
          type:         'tree-node',
          // 设置锚点的位置  
          anchorPoints: [
            [0, 0.5],
            [1, 0.5],
          ],
        },
        // 边的的类型 用我们渠道的边的类型  
        defaultEdge: {
          type:  graphLayout[layoutType].edgeType,
          style: {
            stroke: '#c0cad4',
          },
        },
        layout: graphLayout[layoutType].config,
        modes:  {
          default: [
            // 展开收缩的事件  
            {
              type:    'collapse-expand',
              trigger: 'click',
              shouldBegin(e) {
                const editSwitchChecked =
                  window.localStorage.getItem('tree-edit-switch') === 'true';

                if (_this.isAdmin && editSwitchChecked) return false;

                return true;
              },
              onChange(item, collapsed) {
                const data = item.get('model');

                data.collapsed = collapsed;

                return true;
              },
            },
            // 框选节点
            {
              type:       'brush-select',
              brushStyle: {
                lineWidth:   1,
                fillOpacity: 0.1,
                fill:        '#4088fc',
                stroke:      '#4088fc',
              },
            },
            // 滚动画布   
            'scroll-canvas',
            // 拖拽画布  
            'drag-canvas',
          ],
        },
        // 加载插件 宫格 右键菜单 小地图 提示 还有 工具栏等  
        plugins: [grid, menu, minimap, tooltip, toolbar],
      });
    },
```

### 数据格式

```js
// 大概的数据格式
const mockData = {
  id:       '1629898606491758927',
  depth:    0,
  label:    '前端技能树',
  children: [
    {
      id:    '1629898616632792605',
      depth: 1, // 节点深度 可以理解为节点层级
      label: 'HTML',
      data:  {
        progress: 33.33,
      },
        children: [
            {
              id:    '1629898631654164376',
              label: 'canvas',
              depth: 3,
              data:  {
                score:   0,
                QRCode:  'https://',
                testURL: 'https://',
              },
            },
            {
              id:    '1629898638112788312',
              label: 'websocket',
              depth: 3,
              data:  {
                score:  0,
                QRCode: '',
              },
            },
            {
              id:    '1629898644895766577',
              label: 'web worker',
              depth: 3,
              data:  {
                score: 10,
              },
            },
          ],
        },
      ],
    }
]      
```

### createGraph.registerNode 绘画节点

- 逻辑

```markdown
1. 根节点是 带圆角矩形背景颜色 
2. 子节点 前面是带图标的
3. 并且子节点的文字 没有背景 都是在线上显示
4. 一级 子节点后面 还有标注 自己子节点的数量 是一个 圆角矩形 带背景 中间文字 是子节点的数量 
```

- 代码

```js
registerNode() {
      registerNode('tree-node', {
        draw(cfg, group) {
          // 拿到文字 层级 和 数据 还有子节点
          const { label, depth, data, children } = cfg;
          // 判断 是不是根节点  
          const rootNode = depth === 0;
		 // 设置高 
          const height = 28;
          // 设置默认宽度  
          const countWidth = 22;
          // 拿到文字的宽度  
          const textWidth = Util.getTextSize(String(label), 12)[0];
          // 默认样式  
          const nodeWidth =
            baseConfig.nodePaddingLeft +
            textWidth +
            baseConfig.nodePaddingRight +
            (children && children.length ? countWidth : 0) +
            10;
          // 判断是左侧 还是右侧  
          const isRight = cfg.x > 0;
		 // 默认的样式配置
          const keyShapeAttrs = {
            width:  nodeWidth,
            height,
            x:      0,
            y:      0,
            radius: 5,
            cursor: 'pointer',
          };
          // 开始绘画所有的节点 矩形  
          const keyShape = group.addShape('rect', {
            attrs: keyShapeAttrs,
            name:  'root-key-shape-rect-shape',
          });
		 // 如果是根节点 就有颜色背景 如果是子节点 颜色背景都为透明
          group.addShape('rect', {
            attrs: {
              x:       0,
              y:       0,
              width:   nodeWidth,
              height,
              fill:    '#e8f7ff',
              cursor:  'pointer',
              radius:  14,
              opacity: rootNode ? 1 : 0,
            },
            name: 'main-shape',
          });

          //如果是 添加文本元素
          if (rootNode) {
            // 绘画文字
            group.addShape('text', {
              attrs: {
                text:         label,
                x:            (nodeWidth - textWidth) / 2,
                y:            height / 2,
                textAlign:    'left',
                textBaseline: 'middle',
                fill:         '#222',
                fontSize:     12,
                cursor:       'pointer',
              },
              name: 'root-text-shape',
            });
          } else {
            // 非根节点 判断左右之后 
            group.addShape('text', {
              attrs: {
                text:         label,
                textAlign:    'left',
                textBaseline: 'top',
                fill:         '#222',
                fontSize:     12,
                cursor:       'pointer',
                x:            isRight ? 10 + 10 : nodeWidth - textWidth,
                y:            0,
              },
              name: 'not-root-text-shape',
            });

            // 绘画子节点的 底部横线
            const lineLongth =
              nodeWidth - countWidth + (children && children.length ? 0 : 14);

            group.addShape('path', {
              attrs: {
                path: [
                  ['M', isRight ? 0 : nodeWidth, height / 2],
                  ['L', isRight ? lineLongth : 10, height / 2],
                ],
                stroke:    '#AAB7C4',
                lineWidth: 1,
              },
              name: 'node-path-shape',
            });

            // 名称前面加个图标 判断好左右
            group.addShape('text', {
              attrs: {
                fontSize:   12,
                fontFamily: 'iconfont',
                text:       data && data.progress ? '\ue708' : '\ue616',
                fill:       data && data.progress ? '#333' : '#aaa',
                x:          isRight ? 0 : nodeWidth - textWidth - 18,
                y:          12,
              },
            });
		   // 绘制标有 子节点数量的 圆角矩形 节点
            if (children && children.length) {
              // 添加子节点数量
              const countHeight = 12;
			 // 绘制 一个圆角矩形
              group.addShape('rect', {
                attrs: {
                  width:  countWidth,
                  height: countHeight,
                  radius: 6,
                  stroke: '#5CDBD3',
                  fill:   '#E6FFFB',
                  x:      isRight ? nodeWidth - countWidth : 0,
                  y:      8,
                },
              });
			 // 绘制 文字 文字 是子节点的数组的长度 也就是数量
              group.addShape('text', {
                attrs: {
                  fill:      '#222',
                  fontSize:  10,
                  cursor:    'pointer',
                  textAlign: 'center',
                  width:     countWidth,
                  text:      '${children?.length}',
                  x:         isRight ? nodeWidth - countWidth / 2 : countWidth / 2,
                  y:         20,
                },
              });
            }
          }
		 // 最后返回节点
          return keyShape;
        },
    },
```

createGraph.registerEdge 绘画边

- 逻辑

```markdown
1. 就是调用 脑图的方法 去绘画边
2. 这里我们绘制了 两套 边的 方法
3. 当我们切换布局的时候 需要 切换 g6 的边的布局
```

- 代码 

```js
// 自定义边
        registerEdge(registerEdge) {
            // 注册脑图用的顺滑曲线
            registerEdge('smooth-edge', {
                draw(cfg, group) {
                    // 拿到 线的 起始点 和重点
                    const { startPoint, endPoint } = cfg;
                    // 算出 贝塞尔的 弧度 
                    const hgap = endPoint.x - startPoint.x;

                    const path = [
                        // 开始画起点
                        ['M', startPoint.x, startPoint.y],
                        // 贝塞尔的 边
                        [
                            'C',
                            startPoint.x + hgap / 4,
                            startPoint.y,
                            endPoint.x - hgap / 2,
                            endPoint.y,
                            endPoint.x,
                            endPoint.y,
                        ],
                    ];
                    // 绘画的路径
                    const shape = group.addShape('path', {
                        attrs: {
                            stroke: '#AAB7C4',
                            path,
                        },
                        name: 'smooth-path-shape',
                    });

                    return shape;
                },
            });

            // 注册文件树系统的边
            registerEdge('step-line', {
                getControlPoints(cfg) {
                    const startPoint = cfg.startPoint;

                    const endPoint = cfg.endPoint;

                    return [
                        startPoint,
                        {
                            x: startPoint.x,
                            y: endPoint.y,
                        },
                        endPoint,
                    ];
                },
            }, 'polyline',
            );
        },
```

### 切换布局

- 逻辑

```mariadb
1. 首先我们初始化的时候 会 从浏览器缓存里 去拿 看看 是哪种布局
2. 如果没有就是默认
```

- 代码 

```js
// 拿到布局 没有就是 mindmap 就是脑图
const layoutType = window.localStorage.getItem('graph-layout-type') || 'mindmap';
// 布局映射
const graphLayout = {
   	    // 脑图 布局 走的 布局配置		 
        mindmap: {
            config: {
                ...commonConfig,
                type: 'mindmap',
                direction: 'H',
            },
            edgeType: 'smooth-edge',
            nodeType: 'tree-node',
        },
   		// 文件系统走的 布局配置 
        indented: {
            config: {
                ...commonConfig,
                type: 'indented',
                isHorizontal: true,
                direction: 'LR',
                indent: 30,
            },
            edgeType: 'step-line',
            nodeType: 'file-node',
        },
    };
  
// 拿到 脑图 布局 和 文件布局的 单选按钮

<div class="form-check-group">
    <span class="form-label">选择图布局方式:</span>
    <div class="form-check">
      <input class="form-check-input" type="radio" name="graphLayout" id="mindmap">
      <label class="form-check-label" for="mindmap">脑图布局</label>
    </div>
    <div class="form-check">
      <input class="form-check-input" type="radio" name="graphLayout" id="indented">
      <label class="form-check-label" for="indented">文件系统布局</label>
    </div>
</div>

// 拿到 脑图 布局 和 文件布局的 单选按钮 DOM
const layoutChecks = $('.layout-searcher .form-check-input');
  // 如果有默认布局 就让	默认显示 我们存的
  if (layoutType) {
    // 所有的单选都线设置成false
    layoutChecks.prop('checked', false);
    // 然后 选中的脑图 设置成 true
    $('#' + layoutType).prop('checked', true);
  }	

  // 切换布局方式 
  layoutChecks.change(function () {
    // 拿到了 单选框上设置的id
    const layoutType = this.id;
    // 根据id 找到了对应的布局配置 脑图的 和树
    const currentLayout = graphLayout[layoutType];

    // 存到本地, 下次打开还是上次的布局
    window.localStorage.setItem('graph-layout-type', layoutType);

    // 要将节点/边和默认配置里的属性都改变
    treeGraph.getEdges().forEach(item => {
      // 循环拿到 节点的边 
      const model = item.getModel();
      // 设置了 节点 和 边的 自定义 类型
      model.type = currentLayout.edgeType;
    });
    // 重新渲染视图
    treeGraph.updateLayout(currentLayout.config);
  });
```

### createGraph.createMenu 右键菜单

- 逻辑

```markdown
1. 我们在初始化的时候 已经调用这个方法了
```

- 逻辑

```js
createMenu () {
      const _this = this;

      return new Menu({
        // 右击节点时显示右键菜单
        shouldBegin(e) {
          const model = e.item.getModel();
          let shouldBegin = true;
          if (e.item) {
            const type = e.item.get('type');
		   // 获取到了 你右键的类型
            if (type === 'edge') {
              // 如果你是在边上 点击的右键 那么我们就不显示 右键菜单
              shouldBegin = false;
            } else if (type === 'node') {
			 // 如果你是在节点上 点击的右键 那么就线看看 你是否加载完毕
              if (_this.isAdmin) {
                // 如果加载完毕 就显示右键菜单  
                shouldBegin = true;
              } else if (
                model.children &&
                model.children.length &&
                model.depth !== 0
              ) {
                // 如果 你当前右键节点的数据模型上 有子节点 并且 你不是根节点 那么也显示  
                shouldBegin = true;
              } else {
                // 剩下的 就都不显示右键菜单  
                shouldBegin = false;
              }
            }
            return shouldBegin;
          }
        },
        getContent(e) {
          // 这里就是拼接 右键菜单的HTML 结构
          let menus = '';
          const commands = _this.isAdmin
            ? [
                {
                  command: 'addChild',
                  name:    '添加子节点',
                },
                {
                  command: 'deleteItem',
                  name:    '删除节点',
                },
                {
                  command: 'setToRoot',
                  name:    '作为根节点查看',
                },
              ]
            : [
                {
                  command: 'setToRoot',
                  name:    '作为根节点查看',
                },
              ];

          commands.forEach(item => {
            menus += `<p class="menu-item" command="${item.command}">${item.name}</p>`;
          });

          return menus;
        },
        handleMenuClick(target, item) {
          // 获取 你点击的 右键菜单 按钮 执行对应的函数  
          const command = target.getAttribute('command');

          graphMenuCallBack[command] && graphMenuCallBack[command](item);
        },
      });
    },
```

### 增加节点

- 逻辑

```markdown
1. 首先我们 把执行的函数 都做成了 映射
```

- 代码

```js
const graphMenuCallBack = {
    addChild (item) {
      // 拿到节点上的数据模型  
      const model = item.getModel();
      const id = utils.generateNodeId(); // 这个方法就是返回一个id
      // 这是了节点的 一些数据模型  
      const cfg = {
        id,
        label: '新节点',
        depth: model.depth + 1,
        data:  {
          testUrl:  '',
          QRCode:   '',
          progress: 0,
          score:    0,
        },
        children: [],
      };
      // 然后添加 这个节点 第一个参数 是你面生成的 第二个 是你要插入到谁的id 后面  
      treeGraph.addChild(cfg, model.id);
    },
  };
```

### 删除节点

- 逻辑

```markdown
1. 跟我们新增加节点一样
```

- 代码

```js
const graphMenuCallBack = {
    addChild (item) { ... 好多代码 },
    // 删除节点和边
    deleteItem (item) {
      // 拿到要删除节点的id  
      const { id } = item.getModel();
      // 弹出确认框   
      if (window.confirm('确定要删除该节点吗? 此操作不可撤销!')) {
        // 这里可以理解为   获取原来的 矩阵结构
        const matrix = treeGraph.get('group').getMatrix();
        // 停止动画  
        treeGraph.set('animate', false);
        // 删除 节点  
        treeGraph.removeChild(id);
        // 还原原来的矩阵结构  
        treeGraph.get('group').setMatrix(matrix);
        // 开始动画  
        treeGraph.set('animate', true);
          
        // 我们删除节点的时候 节点会出现错乱 用了以上方法以后就不会存在这种情况了  
      }
    },
  };
```

### 作为根节点查看

- 逻辑

```js
1. 拿到 当前右键节点的id 
2. 通过id 找到数据 
3. 调用changeData 方法 更新数据 让图片居中
```

- 代码

```js
const graphMenuCallBack = {
    // 添加节点的 
    addChild (item) { ... 多代码},
    // 删除节点的
    deleteItem (item) { ... 好多代码 },
    setToRoot (item) {
      // 拿到节点的id  
      const { id } = item.getModel();
      // 通过id 找到 原数据中的 数据  
      const nodes = utils.findById(id, mockData);
      // 设置为当前显示数据 也就是作为根节点查看  
      treeGraph.changeData(nodes);
      // 布局剧中  
      treeGraph.fitCenter();
    },
  };
```

### 更改节点信息

- 逻辑

```markdown
1. 首先必须 是编辑模式下 才可以弹出右侧的 表单框
2. 更改完毕之后 点击提交 才可以更改树上的节点
```

#### 右侧弹框

- 逻辑

```markdown
1. 监听节点的点击事件 
2. 获取 是否是编辑模式 
3. 通过当前节点的id 找到 原数据的父节点的id
4. 显示右侧弹框 并且设置数据
5. 找到所有的子节点数据 并存放在个数组里
6. 设置值
7. 清楚所有的选中状态 并且设置当前的选中状态
```

- 代码

```js
treeGraph.on('node:click', function(e) {
      // 拿到当前节点的数据模型 
      const model = e.item.getModel();
      // 拿到是否为编辑模式
      const editMode = $('#edit-switch').hasClass('switch-checked');

      if (isAdmin && editMode) {
        // 如果是编辑模式 拿到所有的  图谱下的图形
        const children = e.item.get('children') || [];
	    // 在原数据中找到 父亲节点 
        const parentId = utils.findParentId(model.id, mockData);
        // 并显示弹框 设置属性 html 标签上 就有 data-id  和 data-parent-id 等属性
        formParams.addClass('show').attr({
          'data-id':        model.id,
          'data-parent-id': parentId,
        });
        // 存放所有子节点的数据  
        formParamsChildren = children.map(child => {
          return {
            ...utils.findById(child.get('id'), mockData),
            type: 'tree-node',
          };
        });
        // 填充字段 节点名称
        formParams.find('input[data-key="label"]').val(model.label);
        // 考试链接  
        formParams
          .find('input[data-key="testURL"]')
          .val(model.data ? model.data.testURL : '');
        // 二维码链接  
        formParams
          .find('input[data-key="QRCode"]')
          .val(model.data ? model.data.QRCode : '');
      }
      // 并且设置在最前面 
      e.item.toFront();
      // 清楚所有的选中状态 
      treeGraph.getNodes().forEach(item => {
        item.clearStates();
      });
      // 设置当前的选中状态
      e.item.setState('selected', true);
    });
```

#### 点击提交保存修改

- 逻辑

```js
1. 去 弹框的 DOM 上去 id
2. 设置节点数据
3. 通过节点id 找到节点 然后更新设置的节点数据
```

- 代码

```js
// 保存表单
  $('#form-submit').click(function() {
    const data = {
      id:       formParams.attr('data-id'),  // 拿到 当前更改的节点 id
      parentId: formParams.attr('data-parent-id'), // 拿到父节点id
      label:    formParams.find('input[data-key="label"]').val(), // 拿到更改的 文字
      data:     {
        testURL:  formParams.find('input[data-key="testURL"]').val(), // 拿到数据
        QRCode:   formParams.find('input[data-key="QRCode"]').val(), // 拿到链接数据
        progress: 0,
        score:    0,
      },
    };
	// 通过 id 找到节点实例
    const node = treeGraph.findById(data.id);

    if (node) {
      // 获取的节点实例数据模型  
      const model = node.getModel();
	  // 更改数据模型
      model.label = data.label;
      model.data = data.data;
      // 更改子  节点数据模型
      model.children = formParamsChildren;
	  // 或者更改前的矩阵	
      const matrix = treeGraph.get('group').getMatrix();
	  // 暂停动画
      treeGraph.set('animate', false);
      // 更新数据 		
      treeGraph.updateChild(model, data.parentId);
      // 重新渲染’  
      treeGraph.render();
      // 设置原来的矩阵  
      treeGraph.get('group').setMatrix(matrix);
      treeGraph.set('animate', true);
    }
    // 关闭弹框  
    formParams.removeClass('show');
    window.alert('保存成功!');
  });
```

## 拖拽连线

-  可以从左侧的物料区 拖拽到画布 节点
-  节点和节点之间的锚点 可以连线

### 物料拖拽

- 逻辑

```markdown
1. 绑定了 dragstart 事件 并设置了数据 拿到每个节点上的 自定义属性 也就是 节点类行
2. 在画布中监听了 drop 事件 并从事件对象中拿到了 拖拽的值 然后添加节点
```

- 代码

```vue
<template>
  <div class="materials">
    矩形图标  
    <i
      draggable
      data-shape="rect"
      class="iconfont icon-rect"
      @dragstart="dragstart"
    />
     圆形图标  
    <i
      draggable
      data-shape="circle"
      class="iconfont icon-circle"
      @dragstart="dragstart"
    />
      椭圆图标  
    <i
      draggable
      data-shape="ellipse"
      class="iconfont icon-ellipse"
      @dragstart="dragstart"
    />
    <i
      draggable
      data-shape="diamond"
      class="iconfont icon-diamond"
      @dragstart="dragstart"
    />
  </div>
</template>

<script>
  export default {
    methods: {
      dragstart(event) {
        // 给拖拽的事件对象 设置 值 shape 就是拖拽的图形  
        event.dataTransfer.setData('dragSource', JSON.stringify({
          shape: event.target.getAttribute('data-shape'),
        }));
      },
    },
  };
</script>
```

```js
// 画布监听了 拖拽松开事件 然后拿到了事件对象 上面有我们这只的 参数 
this.graph.on('drop', e => {
  if(e.originalEvent.dataTransfer) {
    const { shape } = JSON.parse(e.originalEvent.dataTransfer.getData('dragSource'));
      // 然后创建节点
      this.graph.addItem('node', {
      type:  shape,
      label: Math.random() * 100,
      x:     e.canvasX,
      y:     e.canvasY,
    });
  }
});
```

### 节点连线

- 逻辑

```markdown
1. 首先初始化了画布 锚点都有位置
2. 然后给锚点绑定了事件 分别是 拖拽前 拖拽中 和 松手后 
3. 在上面的那个事件中 分别 有创建边的逻辑等
```

- 代码

```js
// 初始化
// 画布默认渲染两个节点
const data = {
    nodes: [{
      id:    '0',
      x:     300,
      y:     200,
      label: '1',
    }, {
      id:    '1',
      x:     300,
      y:     400,
      label: '2',
    }],
  };
  // 这些锚点的坐标 到时候 需要根据节点的宽高 去计算出来 画来锚点
  const anchorPointMap = [
    [0, 0.5],
    [0.5, 0],
    [1, 0.5],
    [0.5, 1],
  ];


```

```js
// 初始化
const grid = new G6.Grid();
const graph = new G6.Graph({
  container:   document.getElementById('graph'),
  width:       window.innerWidth - 40,
  height:      window.innerHeight - 40,
  defaultNode: {
    type:         'rect',
    // 锚点显示的位置 这个就是我们上面配置的坐标  
    anchorPoints: anchorPointMap,
    style:        {
      width:  170,
      height: 50,
      radius: 4,
      fill:   '#5cbc5a',
      stroke: '#5cbc5a',
    },
    labelCfg: {
      style: {
        fontSize: 14,
        fill:     '#fff',
      },
    },
  },
  // 边的连线 默认 是 曲线  
  defaultEdge: {
    type:  'cubic',
    style: {
      stroke: '#ed6fb1',
    },
  },
  modes: {
    default: ['drag-node', 'drag-canvas'],
  },
  plugins: [grid],
});
```

```js
// 初始化完毕之后绘制锚点
drawAnchors() {
    // 拿到所有节点
    this.graph.getNodes().forEach(item => {
      this.drawAnchor(item);
    });
  },

drawAnchor(item) {
        // item 是节点的实例 拿到 节点实例上的数据模型
        const { id, style: { width, height } } = item.get('model');
        // 获取图形
        const group = item.get('group');

        for(let i = 0; i < 4; i++) {
          // 计算绘画锚点的位置  
          const x = width * (anchorPointMap[i][0] - 0.5);
          const y = height * (anchorPointMap[i][1] - 0.5);

          // 锚点
          group.addShape('circle', {
            attrs: {
              r:      5,
              cursor: 'move',
              stroke: '#333',
              fill:   '#fff',
              x,
              y,
            },
            anchorIndex: i,
            draggable:   true,
            name:        'anchor',
            nodeId:      id,
          });
        }
      }, 
```

```js
// 拖拽锚点连线
// 因为 边是创建出来的 所以 我们没创建一条边 就要记录一下 位置 id 和那个节点开始的 等信息
const edgeCfg = {
  sourceId:     '',
  sourceAnchor: '',
  startPoint:   {
    x: 0,
    y: 0,
  },
};
```

```js
// 开始拖拽 给 锚点绑定 拖拽事件  组织默认行为 记录坐标等
this.graph.on('anchor:dragstart', e => {
  e.stopPropagation();
  // 拿到节点实例	
  const node = e.item;
  // 获取节点的坐标
  const bBox = node.getBBox();
  // 拿到图谱
  const group = node.getContainer();
  // 拿到 节点id  
  const { id } = node.getModel();
  // 这里就是拿到 我们拖拽锚点的索引  
  const { anchorIndex } = e.target.cfg;
  // 通过索引 我们拿到了 锚点的坐标 这里就知道 我们拖拽的锚点 是在上面 还是下面 左边还是右边  
  const p = anchorPointMap[anchorIndex];
  // 记录 边开始的坐标 
  edgeCfg.startPoint.x = e.canvasX;
  edgeCfg.startPoint.y = e.canvasY;
  // 记录边的id  
  edgeCfg.sourceId = id;
  // 记录边的索引  
  edgeCfg.sourceAnchor = anchorIndex;
  // 添加一条线的图形
  const line = group.addShape('path', {
    attrs: {
      stroke:   '#1890FF',
      lineDash: [5, 3],
      path:     [
        // 起始点x坐标 和 y 坐标 根据 节点的位置做计算  
        ['M', bBox.width * (p[0] - 0.5), bBox.height * (p[1] - 0.5)],
      ],
    },
    name: 'dashed-path',
  });
  // 让所有图形都在 最上面显示	
  node.toFront();
  group.toFront();
  line.toFront();
});
```

```js
// 拖拽中 需要拿到 你拖拽开始的 时候绘画的线 然后根据鼠标拖拽的位置 计算 他的终点坐标 然后更改 线的属性
this.graph.on('anchor:drag', e => {
          // 组织默认行为
          e.stopPropagation();
	      // 拿到节点实例		
          const node = e.item;
          // 获取图谱
          const group = node.getContainer();
          // 找到线的实例 
          const dashedPath = group.get('children').find(c => c.cfg.name === 'dashed-path');
          // 找到 坐标
    	 const canvasBox = group.get('children')[0].get('canvasBBox');
		 // 如果 找到了这个线的实例
          if(dashedPath) {
            // 就拿到 线的配置
            const { path } = dashedPath.attrs;

            /* 计算方法:
            * 鼠标在画布上的位置 - box左上角 - width/2 => 当前鼠标的坐标
            */
            // 添加 l 也就是终点的 坐标  
            path[1] = ['L', e.x - canvasBox.x - canvasBox.width / 2 - 1, e.y - canvasBox.y - canvasBox.height / 2 - 1];
            // 时时更新 线  
            dashedPath.attr({
              path: [[...path[0]], path[1]],
            });
            dashedPath.toFront();
          }
        });
```

```js
// 拖拽结束 要看看 你是不是 在 目标节点的锚点上 释放的 并且 还不能是本节点

// 拖拽结束
this.graph.on('anchor:dragend', e => {
  e.stopPropagation();
  // 拖拽结束的时候 要看看 你拖拽结束的时候不是 锚点 或者 是不是在本节点上
  if(e.target.cfg.name === 'anchor' && e.target.cfg.nodeId !== e.item.getModel().id) {
    // 移动到了其他节点上
  } else {
    // 此时应删除连线, 并清空 edge 对象
    edgeCfg.sourceId = '';
    edgeCfg.anchorIndex = '';
  }

  // 移除虚线
  const node = e.item;
  const group = node.getContainer();
  // 找到 线的实例   
  const dashedPath = group.get('children').find(c => c.cfg.name === 'dashed-path');  
  // 然后移出 	
  if(dashedPath) {
    dashedPath.remove();
  }
});
```

```js
// 如果是目标节点上 释放鼠标的  我们就创建 边 然后 我们有开始的节点id 和锚点的索引 

// 在锚点上释放鼠标
this.graph.on('anchor:drop', e => {
  e.stopPropagation();
  // 拿到目标的id  
  const { id } = e.item.getModel();
  const { anchorIndex } = e.target.cfg;

  // 发生连线
  if(edgeCfg.sourceId) {
    // 添加连线
    this.graph.addItem('edge', {
      fill:         '#333',
      label:        'edge',
      source:       edgeCfg.sourceId,
      sourceAnchor: edgeCfg.sourceAnchor,
      target:       id,
      targetAnchor: anchorIndex,
    });
  }
});
```













